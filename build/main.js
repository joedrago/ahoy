// Generated by CoffeeScript 2.7.0
(function() {
  var StreamZip, dirExists, dircompare, downloadLatestZip, findLatestFileLinks, fs, generateNowString, main, makeFreshDownloadDir, pad, path, puppeteer, rimraf, updateMod, waitForFile, waitMS;

  fs = require('fs');

  rimraf = require('rimraf');

  path = require('path');

  puppeteer = require('puppeteer');

  StreamZip = require('node-stream-zip');

  dircompare = require('dir-compare');

  pad = function(s, fill = '0', count = 2) {
    s = String(s);
    while (s.length < count) {
      s = String(fill) + s;
    }
    return s;
  };

  generateNowString = function() {
    var d;
    d = new Date();
    return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  };

  makeFreshDownloadDir = function(dir) {
    if (fs.existsSync(dir)) {
      rimraf.sync(dir);
    }
    return fs.mkdirSync(dir, {
      recursive: true
    });
  };

  waitMS = function(time) {
    return new Promise(function(resolve, reject) {
      return setTimeout(resolve, time);
    });
  };

  dirExists = function(dir) {
    if (!fs.existsSync(dir)) {
      return false;
    }
    if (!fs.lstatSync(dir).isDirectory()) {
      return false;
    }
    return true;
  };

  findLatestFileLinks = async function(modName) {
    var browser, i, len, link, lowerModName, page, results, sidebarLinks, sidebarTitles, title, titleIndex;
    lowerModName = modName.toLowerCase();
    browser = (await puppeteer.launch({
      headless: true
    }));
    page = (await browser.newPage());
    await page.setUserAgent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36");
    await page.goto(`https://www.curseforge.com/wow/addons/${lowerModName}`);
    sidebarTitles = (await page.$$eval('.e-sidebar-subheader > a', function(elements) {
      return elements.map(function(e) {
        return e.innerHTML;
      });
    }));
    sidebarLinks = (await page.$$eval('.cf-recentfiles > li > div > a.overflow-tip', function(elements) {
      return elements.map(function(e) {
        return {
          href: e.href,
          name: e.dataset.name
        };
      });
    }));
    await browser.close();
    if (sidebarTitles.length !== sidebarLinks.length) {
      console.ERROR(`findLatestFileLinks() is probably messed up. Please debug with mod name \"${modName}\".`);
      return null;
    }
    results = [];
    for (titleIndex = i = 0, len = sidebarTitles.length; i < len; titleIndex = ++i) {
      title = sidebarTitles[titleIndex];
      link = sidebarLinks[titleIndex];
      results.push({
        version: title,
        filename: link.name,
        href: link.href
      });
    }
    return results;
  };

  waitForFile = function(downloadDir, timeout) {
    return new Promise(function(resolve, reject) {
      var interval, intervalTime, remainingTime;
      intervalTime = 1000;
      remainingTime = timeout;
      return interval = setInterval(function() {
        var downloadedFilenames;
        downloadedFilenames = fs.readdirSync(downloadDir);
        console.log("checking files: ", downloadedFilenames);
        if (downloadedFilenames.length > 0 && !downloadedFilenames[0].match(/crdownload/)) {
          clearInterval(interval);
          resolve(true);
          return;
        }
        remainingTime -= intervalTime;
        if (remainingTime < 0) {
          clearInterval(interval);
          resolve(false);
        }
      }, intervalTime);
    });
  };

  // returns null on success, or error string on failure
  // WARNING: tempOutputPath does not have to exist yet, but will be nuked! don't be an idiot!
  // Upon success "#{tempOutputPath}/extracted" will have stuff in it
  downloadLatestZip = async function(modName, versionFilter, tempOutputPath) {
    var browser, client, count, downloadDir, downloadSuccess, downloadUrl, downloadedFilename, downloadedFilenames, extractDir, file, fileId, files, i, latestFile, len, lowerModName, matches, page, zip;
    console.log(`Finding latest download for ${modName} (${versionFilter})...`);
    files = (await findLatestFileLinks(modName));
    if (files == null) {
      return `[${modName}] Failed to find latest file links`;
    }
    latestFile = null;
    for (i = 0, len = files.length; i < len; i++) {
      file = files[i];
      if (file.version.indexOf(versionFilter) !== -1) {
        latestFile = file;
        break;
      }
    }
    if (latestFile == null) {
      return `[${modName}] Failed to find matching version (${versionFilter}) out of ${files.length} choices`;
    }
    lowerModName = modName.toLowerCase();
    browser = (await puppeteer.launch({
      headless: true
    }));
    page = (await browser.newPage());
    await page.setUserAgent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36");
    await page.goto("https://example.com");
    downloadDir = path.resolve(tempOutputPath);
    // console.log "temp download path: #{downloadDir}"
    makeFreshDownloadDir(downloadDir);
    client = (await page.target().createCDPSession());
    await client.send('Page.setDownloadBehavior', {
      behavior: 'allow',
      downloadPath: downloadDir
    });
    matches = latestFile.href.match(/\/files\/(\d+)/);
    if (matches == null) {
      return `[${modName}] Couldn't make sense of download link: ${latestFile.href}`;
    }
    fileId = parseInt(matches[1]);
    if ((fileId == null) || (fileId < 1)) {
      return `[${modName}] Download link has no ID in it: ${latestFile.href}`;
    }
    downloadUrl = `https://www.curseforge.com/wow/addons/${lowerModName}/download/${fileId}`;
    console.log(`Downloading [${latestFile.filename}]: ${downloadUrl}`);
    await page.goto(downloadUrl);
    // manually click on the "here" link to skip the 5 second wait
    await page.$$eval('a', function(elements) {
      var e, j, len1;
      for (j = 0, len1 = elements.length; j < len1; j++) {
        e = elements[j];
        if (e.innerHTML === "here") {
          e.click();
          return;
        }
      }
    });
    downloadSuccess = (await waitForFile(downloadDir, 15000));
    await browser.close();
    // console.log "downloadSuccess: #{downloadSuccess}"
    downloadedFilenames = fs.readdirSync(downloadDir);
    if (downloadedFilenames.length !== 1) {
      return `[${modName}] Failed to find a downloaded file from: ${downloadUrl}`;
    }
    downloadedFilename = path.resolve(downloadDir, downloadedFilenames[0]);
    extractDir = path.resolve(downloadDir, "extracted");
    fs.mkdirSync(extractDir, {
      recursive: true
    });
    zip = new StreamZip.async({
      file: downloadedFilename
    });
    count = (await zip.extract(null, extractDir));
    // console.log("Extracted #{count} entries.")
    await zip.close();
    return null;
  };

  updateMod = async function(modName, versionFilter, wowAddonsDir, wowAddonsBackupDir) {
    var backupPath, dir, dirs, dstPath, err, extractedDir, i, len, needsMove, result, srcPath, tmpDir, updatedAtLeastOne;
    tmpDir = "tmp.ahoy.download";
    err = (await downloadLatestZip(modName, versionFilter, tmpDir));
    if (err != null) {
      console.err(`Failed to download latest zip: ${err}`);
      return;
    }
    extractedDir = path.resolve(tmpDir, "extracted");
    dirs = fs.readdirSync(extractedDir);
    updatedAtLeastOne = false;
    for (i = 0, len = dirs.length; i < len; i++) {
      dir = dirs[i];
      srcPath = path.resolve(extractedDir, dir);
      if (!fs.lstatSync(srcPath).isDirectory()) {
        continue;
      }
      needsMove = true;
      dstPath = path.resolve(wowAddonsDir, dir);
      if (fs.existsSync(dstPath)) {
        if (!fs.lstatSync(dstPath).isDirectory()) {
          console.error(`ERROR: dstPath isn't a directory: ${dstPath}`);
          continue;
        }
        // console.log "Diffing: #{dir}"
        // console.log "Diffing:\n * #{srcPath}\n * #{dstPath}"
        result = dircompare.compareSync(srcPath, dstPath, {
          compareContent: true
        });
        if (result.same) {
          // console.log "Up to date."
          needsMove = false;
        } else {
          backupPath = path.resolve(wowAddonsBackupDir, `${dir}.${generateNowString()}`);
          console.log(`Backup: ${backupPath}`);
          fs.renameSync(dstPath, backupPath);
        }
      }
      if (needsMove) {
        console.log(`Create: ${dir}`);
        // console.log "Updating:\n *  #{srcPath}\n => #{dstPath}"
        fs.renameSync(srcPath, dstPath);
        updatedAtLeastOne = true;
      }
    }
    if (!updatedAtLeastOne) {
      console.log("Already up to date.");
    }
    if (fs.existsSync(tmpDir)) {
      return rimraf.sync(tmpDir);
    }
  };

  main = async function() {
    var args, config, configFilename, configIndex, configs, dstPath, i, j, k, len, len1, len2, mod, modCount, modIndex, rawConfigFilename, ref, syntax;
    syntax = function() {
      console.log("Syntax: ahoy [-h]");
      console.log("        ahoy [-v] [-m] [configFile|dirWithAhoyJSON]");
      console.log("");
      console.log("Options:");
      console.log("        -h,--help         This help output");
      console.log("        -v,--verbose      Verbose output");
      console.log("        -m,--missing      Only update missing mods (default: update all listed mods)");
      console.log("");
      console.log("If a directory is supplied, ahoy will look in that directory for a file named ahoy.json.");
      console.log("If no path is supplied, ahoy will look in the current directory for a file named ahoy.json.");
      return process.exit(1);
    };
    args = require('minimist')(process.argv.slice(2), {
      boolean: ['h', 'v', 'm'],
      alias: {
        help: 'h',
        verbose: 'v',
        missing: 'm'
      }
    });
    if (args.help) {
      syntax();
    }
    rawConfigFilename = "ahoy.json";
    if (args._.length > 0) {
      rawConfigFilename = args._.shift();
    }
    configFilename = path.resolve(rawConfigFilename);
    if (dirExists(configFilename)) {
      configFilename = path.resolve(configFilename, "ahoy.json");
    }
    if (!fs.existsSync(configFilename)) {
      console.error(`ERROR: No config file found: ${configFilename}`);
      return;
    }
    console.log(`Config: ${configFilename}`);
    configs = JSON.parse(fs.readFileSync(configFilename, "utf8"));
    for (i = 0, len = configs.length; i < len; i++) {
      config = configs[i];
      if ((config.addonsDir == null) || (config.backupDir == null) || (config.version == null) || (config.mods == null)) {
        console.error("ERROR: Config requires: addonsDir, backupDir, version, mods");
        return;
      }
      config.addonsDir = path.resolve(config.addonsDir);
      if (!dirExists(config.addonsDir)) {
        console.error(`ERROR: addonsDir doesn't exist: ${addonsDir}`);
        return;
      }
      config.backupDir = path.resolve(config.backupDir);
      if (!dirExists(config.backupDir)) {
        console.log(`Creating backup dir: ${config.backupDir}`);
        fs.mkdirSync(config.backupDir, {
          recursive: true
        });
      }
      if (config.mods.length < 1) {
        console.error("ERROR: No mods listed.");
        return;
      }
    }
    for (configIndex = j = 0, len1 = configs.length; j < len1; configIndex = ++j) {
      config = configs[configIndex];
      console.log("\n------------------------------------------------------------------------------");
      console.log(`** Config ${configIndex + 1} of ${configs.length} **\n`);
      console.log(`Version  : ${config.version}`);
      console.log(`AddonsDir: ${config.addonsDir}`);
      console.log(`BackupDir: ${config.backupDir}`);
      console.log(`\nUpdating ${config.mods.length} mods...`);
      modCount = config.mods.length;
      ref = config.mods;
      for (modIndex = k = 0, len2 = ref.length; k < len2; modIndex = ++k) {
        mod = ref[modIndex];
        dstPath = path.resolve(config.addonsDir, mod);
        if (args.missing && dirExists(dstPath)) {
          console.log(`\n[${modIndex + 1}/${modCount}] Skipping ${mod}...`);
          continue;
        }
        console.log(`\n[${modIndex + 1}/${modCount}] Updating ${mod}...`);
        await updateMod(mod, config.version, config.addonsDir, config.backupDir);
      }
    }
    console.log("\n------------------------------------------------------------------------------");
    return console.log("\nAll configs complete!");
  };

  module.exports = main;

}).call(this);
